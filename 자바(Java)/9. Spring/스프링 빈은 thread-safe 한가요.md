## 스프링 빈은 thread-safe 한가요?

아니요.

**기본적으로 스프링 빈은 싱글톤 스코프로 생성되기 때문에 thread-safe하지 않습니다.** 상태를 가지지 않거나, 상태를 조심스럽게 관리해야 thread-safe하게 사용할 수 있습니다.

## **Thead Safe**

**스레드 안전(thread safety)** 은 **멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다.** 보다 엄밀하게는 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다.

## 답변에 대한 자세한 설명

**스프링 빈**의 기본 스코프는 **싱글톤**이고, **스프링 환경**은 **멀티 스레드**인데 ‘왜 하나의 공유자원(싱글톤 객체)을 여러 스레드에서 다루는데 문제가 되지 않을까?’ 라는 의문을 가져본 적이 있는가?

**싱글톤 패턴(Singleton pattern)** 을 따르는 클래스는 **생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴**한다. 주로 공통된 객체를 여러 개 생성해서 사용하는 DBCP(Database Connection Pool)와 같은 상황에서 많이 사용된다.

마찬가지로 **스프링 빈도** 공통된 객체를 여러 개 생성해서 메모리를 쓰는 것보다 **하나의 객체를 통해 로직을 수행**하는 것을 선호한다.

### 스레드를 통해 갖고 있는 값을 변경시키고 출력해보자.

- 간단하게 **싱글톤 객체**를 통해 덧셈을 하는 프로그램 : 비동기 특성상 순서는 보장되지 못하는데, 결과는 다 보장된다. 다시 말해, thread-safe 하다.

- **상태를 가지는(전역변수가 있는) 싱글톤 객체**를 통해 덧셈을 하는 프로그램 : 데이터에 문제가 발생한다. 하나의 공유자원을 놓고 여러 개의 스레드가 읽기/쓰기를 하며 데이터 조작 중 문제가 발생한 것이다.(Race Condition) 이 경우는 thread-safe 하지 못하다.

### 체크 포인트 ✅

- 전자(불변 객체) : 값 외부에서 전달받아 변경시킴

- 후자(가변 객체) : 내부에서 갖고 있는 값을 변경시킴

> JVM에서 각각의 스레드는 자신의 stack 영역을 갖고 있지만, heap 영역은 스레드간에 공유를 하고 있다.(간단하게 stack은 지역변수, heap은 전역변수라고 생각하면 된다) 그래서 상태를 가지는 가변 객체의 경우 문제가 발생한 것이다.
>
> **싱글톤 스코프의 스프링 빈도 결국 위의 싱글톤 예제와 원리는 동일하기 때문에 멀티 스레드 환경에서의 가변 객체일 경우 thread-safe하지 못하다.**
>
> 스프링 빈(`@Controller`, `@Service`, `@Repository`, `@Component` 어노테이션이 달린 객체 등)의 전역변수엔 주로 스프링 빈과 같은 불변 객체들이 있지 VO, DTO, Map 같은 가변 객체가 존재하지 않았을 것이다. 만약 있다면 `synchronized` 키워드나 `concurrent` 패키지의 클래스들을 사용해 동시성 문제를 해결했을 것이다. 그리고 스프링 빈 사이의 데이터를 주고받을 땐 스프링 빈의 상태를 변경시키는 게 아니라 메소드의 파라미터를 이용했을 것이다. 자신도 모르게 관행에 따라 개발하다보니 thread-safe 하게 개발한 것이다.

**결론 : 스프링 빈을 상태를 변경할 수 있게 만든다면, Thread-safe 하지 않다.**

## 참고

[[OS] Thread Safe란?](https://gompangs.tistory.com/entry/OS-Thread-Safe란)

[[java] 쓰레드 세이프(Thread Safe)](https://ldh-6019.tistory.com/481)

[스프링 빈과 Thread-Safe](https://ehdvudee.tistory.com/18)
